<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junwen‘s Blog</title>
  
  
  <link href="http://jwfing.github.io/atom.xml" rel="self"/>
  
  <link href="http://jwfing.github.io/"/>
  <updated>2026-02-01T18:49:23.940Z</updated>
  <id>http://jwfing.github.io/</id>
  
  <author>
    <name>Junwen Feng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>别急，AI 还没准备好</title>
    <link href="http://jwfing.github.io/2026/01/31/hold-on-ai-is-not-ready-yet/"/>
    <id>http://jwfing.github.io/2026/01/31/hold-on-ai-is-not-ready-yet/</id>
    <published>2026-02-01T07:08:50.000Z</published>
    <updated>2026-02-01T18:49:23.940Z</updated>
    
    <content type="html"><![CDATA[<p>过去一年，我做了两个 AI 相关项目：一个是 Legal Agent，另一个是 AI Agent 的后端基础设施。借此机会，我对 AI 的实际应用有了一些具体感受，在此做个总结。</p><h2 id="AI-能做什么"><a href="/2026/01/31/hold-on-ai-is-not-ready-yet/#AI-能做什么" class="headerlink" title="AI 能做什么"></a>AI 能做什么</h2><p>AI 能做很多事，尤其在软件开发领域，已经可以替代大部分初级工程师的工作。</p><p>从实际体验来看，当任务的输入输出明确、过程确定时——比如写一个计算余弦相似度的函数、实现 PageRank 算法——AI 表现出色。但如果任务没有既定模式，比如为混杂排版的 PDF 写一个文本提取算法，或者处理某个从未出现过的问题，它的表现就开始平庸了。另一个明显的短板是：AI 很难写出一致性良好的系统，尤其是经过多轮迭代之后。</p><p>法律领域也是如此。尽管 Legal AI 产品层出不穷，但据说律师用得最多的还是 ChatGPT，且所有结论仍需人工审核。这固然与法律行业的特殊要求有关，但也说明 AI 还无法作为独立律师「执业」。</p><p>目前来看，AI 在脑力劳动方面尚不能完全替代人，但可以显著提升工作效率。</p><h2 id="AI-局限性的本质"><a href="/2026/01/31/hold-on-ai-is-not-ready-yet/#AI-局限性的本质" class="headerlink" title="AI 局限性的本质"></a>AI 局限性的本质</h2><p>当下讨论的 AI 基本等同于基于 Transformer 架构的大语言模型（LLM）。它本质上是对海量预训练数据进行概率预测，因此结果高度依赖训练数据的覆盖面和时效性，反映的也是训练数据的「平均」水平。</p><p>很多时候，这个水平已经超过了人类的「平均」水平，所以大家会觉得「惊艳」。但对于训练数据覆盖不足的问题，AI 的表现会断崖式下跌，而且它在持续推理能力上也不及人类。</p><p>另一个值得思考的问题是：这种「表现」出来的智能是否就是真正的智能？AI 是否真正理解问题？我倾向于保守的回答。</p><p>AI 之所以在软件开发领域应用广泛，很大程度上是因为研究 AI 的人本身就是软件开发者，相关知识已经大量灌入预训练模型。但即便如此，AI 目前仍只是一个高级工具，离不开人的监督。</p><h2 id="开发者该如何与-AI-协作"><a href="/2026/01/31/hold-on-ai-is-not-ready-yet/#开发者该如何与-AI-协作" class="headerlink" title="开发者该如何与 AI 协作"></a>开发者该如何与 AI 协作</h2><p>普通开发者还该不该拥抱 AI？什么任务适合交给 AI，什么任务必须自己把控？</p><p>对我而言，AI 就是一个趁手的高级工具。经过一年的高强度使用，我已经很少从头手写代码了。大部分代码交给 AI 来写，我主要负责设计、整合和把关。无论何时，AI 写出的代码我都会 review，确保架构合理、实现一致。当 AI 陷入「鬼打墙」状态时，我负责把它拉出来。</p><p>尽管 AI 仍会犯错，但我们应该拥抱它。</p><h2 id="AI-带来的焦虑"><a href="/2026/01/31/hold-on-ai-is-not-ready-yet/#AI-带来的焦虑" class="headerlink" title="AI 带来的焦虑"></a>AI 带来的焦虑</h2><p>尽管 AI 目前只是辅助工具，但我相信它会持续迭代，未来可能出现真正的智能。我不质疑「AI 是未来」这个判断。</p><p>但正如股票市场，大家交易的是未来预期，放大倍数往往远超理性。这个规律同样适用于当下的 AI 浪潮。AI 似乎成了创业的唯一方向，AI 公司多如过江之鲫，明星公司的成功效应吸引了大批创业者入场厮杀，全方位内卷开始了——硅谷的工程师也开始 007，大家用「创业一年人间三年」来鞭策自己。</p><p>我见过一些创始人，每天关注的都是「xx 产品出圈了，我们要不要抄一个」。Manus 要搞，n8n 要研究，cowork 刚上手，Clawdbot 又爆了……整天追热点，希望能蹭到一波流量。这种心态的「创始人」不在少数。</p><p>我始终认为，创始人要保持定力，有清晰的思路和商业分析能力，能够过滤市场噪音、洞察真实痛点，最终聚集一群人把想法变现。创业公司本身就是创始人的第一个产品，也是最重要的产品——看创始人怎么运营公司，就能看出他们会怎么做产品。</p><h2 id="结语"><a href="/2026/01/31/hold-on-ai-is-not-ready-yet/#结语" class="headerlink" title="结语"></a>结语</h2><p>回到最初的问题：AI 是未来吗？我相信是的。但未来不会一夜之间到来，也不会因为我们焦虑就来得更快。</p><p>与其追逐每一个热点，不如把 AI 当作一个正在成长的工具——用它来放大自己的能力，而不是替代自己的思考。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;过去一年，我做了两个 AI 相关项目：一个是 Legal Agent，另一个是 AI Agent 的后端基础设施。借此机会，我对 AI 的实际应用有了一些具体感受，在此做个总结。&lt;/p&gt;
&lt;h2 id=&quot;AI-能做什么&quot;&gt;&lt;a href=&quot;/2026/01/31/hold-</summary>
      
    
    
    
    
    <category term="产品观察" scheme="http://jwfing.github.io/tags/%E4%BA%A7%E5%93%81%E8%A7%82%E5%AF%9F/"/>
    
    <category term="AI" scheme="http://jwfing.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>转折：2025</title>
    <link href="http://jwfing.github.io/2026/01/03/turning-point-2025/"/>
    <id>http://jwfing.github.io/2026/01/03/turning-point-2025/</id>
    <published>2026-01-03T19:10:52.000Z</published>
    <updated>2026-01-04T04:11:10.250Z</updated>
    
    <content type="html"><![CDATA[<p>2025 年转眼就过去了，回想这一年，还是有很多事情值得记录一下的。</p><h2 id="美漂"><a href="/2026/01/03/turning-point-2025/#美漂" class="headerlink" title="美漂"></a>美漂</h2><p>去年最重要的一件事，是我们一家搬到西雅图生活。</p><p>我此前对美国并不熟悉，语言也不流利。春节刚过，拖着 6 个行李箱落地，机场租车后，儿子坐在副驾，用手机帮我导航去朋友家。就这样，我们开始了这段几乎没有缓冲的旅程。</p><p>初来乍到，更像是衣衫单薄的人被直接丢进急流。虽然有朋友帮忙，但依然手忙脚乱。好在西雅图华人多，一个月后，我在小红书上找到了第一份起步工作；后来又在某个帖子下，机缘巧合地遇到了现在的同事。从 7 月开始做 InsForge，十年之后，竟然在太平洋另一端再次创业。</p><p>这一年里，我是在混乱中向前走的。但回头看，家人比我镇定，孩子的适应能力也超出预期。我们几乎没有讨论「是否适应」，而是直接开始生活。</p><p>大学毕业后我就成了「北漂」，人到中年反而漂向了大洋彼岸。即便最终未必会留下来，这也并不只是换一个居住地，而是离开原有的一整套社会与认知系统，在新的环境中重新被验证，一步步把生活从头搭建起来。过去一年，我在价值观和意识形态上完成了一次跨越，也逐渐建立起一种信心：在世界的任何一个角落，从零开始生活，是一件可以做到的事。</p><h2 id="意义"><a href="/2026/01/03/turning-point-2025/#意义" class="headerlink" title="意义"></a>意义</h2><p>也许是年纪渐长，我开始频繁思考「意义」。</p><ul><li>996 的意义是什么？</li><li>忙碌一生的意义是什么？</li><li>跨越半个地球带孩子来美国求学的意义是什么？</li><li>我活着的意义是什么？</li></ul><p>2025 年末，「斩杀线」这个词在中文社区流行开来。美国社会长期存在 Alice（Asset Limited, Income Constrained, Employed）这一概念，一些老移民也承认，美国的整体运行状态并不乐观，底层生活同样捉襟见肘。</p><p>我无法判断所谓「西大」对下一代而言究竟是更好还是更坏。曾经，我希望尽力为孩子打下基础，帮助他逃离「斩杀线」的威胁；现在逐渐意识到，这个目标并不现实。一方面我自己能力有限，另一方面也明白：一代人有一代人的长征路。</p><p>我能留给孩子的，或许不是安全边界，而是谋生的能力、开阔的视野，以及在关键时刻拥有选择的自由。</p><p>这些问题我并没有答案，只是逐渐意识到它们存在多重可能，而以我当下的认知，很难给出清晰的结论。偶尔会想起那句话：</p><blockquote><p>凡所有相，皆是虚妄；若见诸相非相，即见如来。</p></blockquote><p>或许，这可以遮掩我的迷惘。</p><h2 id="5000-天"><a href="/2026/01/03/turning-point-2025/#5000-天" class="headerlink" title="5000 天"></a>5000 天</h2><p>当人开始思考意义，大抵就意味着时间上的储蓄已然不足。</p><p>与这些思考一同浮现的，是做真正有价值之事的愿望。我很感激过去的十年，也感谢我的合伙人江宏，以及在 LeanCloud 遇到的每一个有意思的灵魂。我始终喜欢写代码，喜欢参与创造过程。</p><p>向前看，留给我完整投入工作的时间，大约只剩 5000 天。退休之后，希望能回归个人兴趣：读书、写字、爬山、亲水，与朋友交谈，在一个不那么喧闹的地方平静生活。</p><p>在那之前，有些事情值得提前准备：</p><ol><li>利用这次旅居的机会，用三年时间把英语真正学好，获得更大的行动自由和理解世界的能力。</li><li>保持持续创造产品的能力，保持对世界的好奇心，即便在退休之后，也能做一些有意思的事情。</li><li>构建稳健的投资体系，让被动收入提供基本的生活缓冲。</li><li>培养一项音乐能力（学会陶笛），让未来的生活多一种表达方式。</li></ol><p>这些都还只是目标，而非计划。</p><h2 id="序章"><a href="/2026/01/03/turning-point-2025/#序章" class="headerlink" title="序章"></a>序章</h2><p>2026 年该如何展开，我还在摸着石头过河，而且我也比较懒惰，不一定能坚持下去。但有一件事，需要从现在就开始执行：</p><p>每天醒来后的第一个小时，远离手机与社交媒体。即便只是发呆，也不要让噪音占据清醒的时间。</p><p>多读书，保持专注。是为序章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2025 年转眼就过去了，回想这一年，还是有很多事情值得记录一下的。&lt;/p&gt;
&lt;h2 id=&quot;美漂&quot;&gt;&lt;a href=&quot;/2026/01/03/turning-point-2025/#美漂&quot; class=&quot;headerlink&quot; title=&quot;美漂&quot;&gt;&lt;/a&gt;美漂&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="年终总结" scheme="http://jwfing.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Is Postgres-aaS a better business?</title>
    <link href="http://jwfing.github.io/2025/12/14/Is-Postgres-aaS-a-better-business/"/>
    <id>http://jwfing.github.io/2025/12/14/Is-Postgres-aaS-a-better-business/</id>
    <published>2025-12-15T01:20:23.000Z</published>
    <updated>2025-12-15T02:29:27.465Z</updated>
    
    <content type="html"><![CDATA[<p>最近同事提起一个国内的产品，主要提供 Postgres 集成服务，将高可用架构部署、可观测性监控、扩展管理、备份恢复等功能整合在一起，以开源形式提供给开发者，主打全生态和便捷管理。这让我思考：我们正在开发的 InsForge 平台是否也可以将后端数据库服务独立出来，打造成一个面向开发者的副产品？</p><p>出于好奇，我调研了市场上现有的类似产品：</p><ol><li><p><a href="https://stackgres.io/">StackGres</a>：作为 Kubernetes Operator，提供高可用、备份恢复、监控可观测性、扩展管理等功能。从社区热度来看，GitHub 上关注度不高（1.3k stars，70 forks），<a href="https://news.ycombinator.com/item?id=28865432">Hacker News</a> 和 <a href="https://www.reddit.com/r/kubernetes/comments/v61ypo/stackgres_postgresql_operator/">Reddit</a> 上的讨论也相对有限，影响力相对较小。</p></li><li><p><a href="https://cloudnative-pg.io/">CloudNativePG</a>：功能上与 StackGres 类似，但社区活跃度明显更高（7.6k stars，567 forks）。作为 CNCF sandbox 项目，与 KubeCon 等官方活动合作紧密。从 <a href="https://www.reddit.com/r/kubernetes/comments/y5nen0/does_anyone_have_experience_to_share_with/">Reddit 讨论</a> 来看，已有不少开发者在生产环境中长期使用。</p></li><li><p><a href="https://aiven.io/">Aiven</a>：不同于前两者的开源项目定位，Aiven 是一个托管平台，可以快速创建云实例来管理 Postgres 服务。它的产品线更加丰富，除 Postgres 外还支持 MySQL、Kafka、ClickHouse、Redis、Elasticsearch 等多种数据库，并提供免费 VM 实例供开发者试用。从 <a href="https://www.reddit.com/r/aiven_io/">Reddit 社区</a> 反馈来看，用户基数和活跃度都不错。</p></li><li><p><a href="https://www.percona.com/postgresql">Percona</a>：定位为企业级 Postgres 发行版，提供全方位的高可用、备份恢复、监控和扩展支持。与上述产品的差异在于，Percona 更像是对 Postgres 的深度优化和增强版本，类似于 Red Hat 之于 Linux 的关系。</p></li></ol><h2 id="Postgres-aaS-是门好生意吗"><a href="/2025/12/14/Is-Postgres-aaS-a-better-business/#Postgres-aaS-是门好生意吗" class="headerlink" title="Postgres-aaS 是门好生意吗?"></a>Postgres-aaS 是门好生意吗?</h2><p>了解完现有产品后，我们来分析一下市场定位：</p><p><strong>不同用户群体的选择逻辑：</strong></p><ul><li><strong>全栈开发者&#x2F;AI Coder</strong>：Supabase 提供的价值在于标准化后端服务，对于 Cursor、Vibe Coder 这类 AI 开发工具来说，开箱即用的完整 BaaS 方案极具吸引力。</li><li><strong>有技术背景的个人开发者</strong>：Aiven 这类平台主要解决数据库运维管理痛点，提供省心的托管服务。</li><li><strong>企业用户</strong>的选择则更加多元：<ul><li>需要 Serverless 数据库服务时，倾向于选择 AWS RDS、Azure Database、GCP Cloud SQL 等公有云服务，因为有更丰富的功能和更可靠的 SLA 保障；</li><li>拥有技术团队的企业，可能更青睐 Percona 这样的企业级发行版，看重其性能优化、可扩展性和专业技术支持；</li><li>技术实力较强且有自建需求的团队，会选择 Kubernetes + StackGres&#x2F;CloudNativePG 的自主部署方案。</li></ul></li></ul><p><strong>市场空间判断：</strong></p><p>从上述分析来看，Postgres-aaS 的市场相对小众，核心受众是有一定技术背景的个人开发者和小型创业公司。但问题是，这个群体的需求似乎已经被 Supabase 这样的完整 BaaS 平台很好地满足了——既然可以获得数据库+认证+存储+实时订阅的全套服务，为什么还要单独使用一个 Postgres-aaS 产品呢？</p><p><strong>技术视角的价值：</strong></p><p>当然，单从技术探索角度来看，Postgres 生态系统确实充满趣味性。结合后端 DevOps 的实际需求，围绕 Postgres-aaS 这个切入点，我们可以深挖高可用架构设计、性能优化、扩展生态整合等诸多技术领域，积累宝贵的工程经验。但这是否足以支撑一个可持续的商业模式，仍需谨慎评估。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近同事提起一个国内的产品，主要提供 Postgres 集成服务，将高可用架构部署、可观测性监控、扩展管理、备份恢复等功能整合在一起，以开源形式提供给开发者，主打全生态和便捷管理。这让我思考：我们正在开发的 InsForge 平台是否也可以将后端数据库服务独立出来，打造成一</summary>
      
    
    
    
    
    <category term="产品观察" scheme="http://jwfing.github.io/tags/%E4%BA%A7%E5%93%81%E8%A7%82%E5%AF%9F/"/>
    
  </entry>
  
  <entry>
    <title>有了这么多 MCP，为什么我还是用不好 AI</title>
    <link href="http://jwfing.github.io/2025/12/07/why-mcps-dont-make-ai-easier/"/>
    <id>http://jwfing.github.io/2025/12/07/why-mcps-dont-make-ai-easier/</id>
    <published>2025-12-08T05:39:02.000Z</published>
    <updated>2025-12-08T06:26:47.431Z</updated>
    
    <content type="html"><![CDATA[<p>这周看到一个比较有意思的产品：<a href="https://www.producthunt.com/products/mcptotal">MCPTotal</a>，在 ProductHunt 上排到了日榜第 5 名，它的 slogan 是「Launch private MCP servers instantly and connect your agents easily」，乍一看也不明白是做什么的，我就照着它的宣传视频走了一遍。</p><p>本质上，这是一个 Agent + MCP Hub 的产品，选择一个 workspace 后，可以与 Agent 对话，为了提升对话质量，可以选择加入多个公开的 MCP Server，平台自动会帮我们加入到 Agent tools 里面。我试着加入了两个 MCP Servers：Context7 和 DeepWiki，然后我希望它帮我分析一下 supabase flutter SDK 的架构和实现细节，agent 的初始回复有模有样，展示了 reasoning 细节，并跟我确认：</p><blockquote><p>Do you have the code already in this workspace, or should I fetch it from a GitHub URL? Also tell me what kind of analysis you want (architecture overview, API surface, bug&#x2F;security spots, tests&#x2F;coverage, performance, upgrade notes, TODOs, or full audit). I can start by listing the repo files and reading key files once you confirm.</p></blockquote><p>我把 supabase flutter SDK 的 codebase 贴上去，他就开始分析了，从过程中可以看到多次调用了 DeepWiki 的 tools，给了我一个分析结果。</p><p>一次体验下来，我觉得这个产品不错啊，自动收集和集成了众多公开的 MCP Server，让普通用户对 MCP 的使用难度降低了很多。我之前还关注过一些 Github 上的 MCP Hub repo，希望在需要的时候可以找到合适的工具，但是总是容易迷失在茫茫多的工具中，不知道该用哪个，并且时间一长遗忘也在所难免。</p><p>想想看，现在已经有这么多的 MCP Server 了，我使用这些第三方服务的次数变多了吗？好像并没有。MCPTotal 可以解决这个问题吗？</p><h2 id="为什么-MCP-难用"><a href="/2025/12/07/why-mcps-dont-make-ai-easier/#为什么-MCP-难用" class="headerlink" title="为什么 MCP 难用"></a>为什么 MCP 难用</h2><p>我自己做开发较多，这时候最常用的就是 Claude Code 这一类的 Coding Agent，要给他们配置上 MCP，还有点麻烦，并且很多时候还是与项目相关的，不同项目需要的 MCP 也不尽相同，所以还是需要频繁地切换和配置。</p><p>对于通用需求，我一般也是 ChatGPT &#x2F; Claude &#x2F; Gemini 三个轮流使用，因为并不清楚有哪些 MCP 可用，所以也懒得去配置了。</p><p>对于 MCP Server 来说，存在以下一些问题阻碍了他们的普及：</p><ol><li>信息孤岛。有多少 MCP Server 可用，每个 MCP Server 的功能和使用方式都不同，需要用户去理解和学习。</li><li>隐私和安全。用户的数据需要在多个 MCP Server 和 Agent 之间传递，但是这些 Server 的隐私和安全措施不同，用户很难评估数据的安全性。</li></ol><p>MCPTotal 做了很好的集成，但是也还有不足：</p><ol><li><p>如果不使用它的 Agent，这种便利性就还是享受不到。MCPTotal Agent 质量如何，是否能成为我日常使用的主力 Agent，还有待观察。</p></li><li><p>其次，MCPTotal 上面的 MCP Server 质量参差不齐，什么时候该使用哪些 tools，还是需要自己去评估。</p></li></ol><h2 id="MCP-的-MCP"><a href="/2025/12/07/why-mcps-dont-make-ai-easier/#MCP-的-MCP" class="headerlink" title="MCP 的 MCP"></a>MCP 的 MCP</h2><p>由此我想到，有没有一种可能，MCP 也可以有 MCP 呢？这样用户只需要接入一个 MCP，这个 MCP 再去调度和管理其他的 MCP Server，用户就只需要关心这个 MCP 即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这周看到一个比较有意思的产品：&lt;a href=&quot;https://www.producthunt.com/products/mcptotal&quot;&gt;MCPTotal&lt;/a&gt;，在 ProductHunt 上排到了日榜第 5 名，它的 slogan 是「Launch private </summary>
      
    
    
    
    
    <category term="产品观察" scheme="http://jwfing.github.io/tags/%E4%BA%A7%E5%93%81%E8%A7%82%E5%AF%9F/"/>
    
    <category term="AI" scheme="http://jwfing.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Understanding the Docker Host Gateway</title>
    <link href="http://jwfing.github.io/2025/10/17/Understanding-the-Docker-Host-Gateway/"/>
    <id>http://jwfing.github.io/2025/10/17/Understanding-the-Docker-Host-Gateway/</id>
    <published>2025-10-18T05:36:24.000Z</published>
    <updated>2025-10-18T05:50:32.322Z</updated>
    
    <content type="html"><![CDATA[<p>在深入理解 Docker 的宿主机网关之前,我们需要先理解网络中「网关」的基本概念。</p><p>在传统网络中,<strong>网关 (Gateway)</strong> 是连接两个不同网络的设备或节点。它就像是两个网络之间的「门」，负责在不同网络之间转发数据包。举个生活中的例子:</p><ul><li>你家里的路由器就是一个网关</li><li>你的电脑(如 192.168.1.100)想访问互联网上的网站</li><li>数据包必须先发送到路由器(如 192.168.1.1)</li><li>路由器再将数据包转发到互联网</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[你的电脑] ---&gt; [家庭路由器/网关] ---&gt; [互联网]</span><br><span class="line">192.168.1.100    192.168.1.1          外部网络</span><br></pre></td></tr></table></figure><p>由此可见，网关有如下作用：</p><ol><li><strong>路由转发</strong>: 将数据包从一个网络转发到另一个网络</li><li><strong>地址转换</strong>: 进行 NAT (网络地址转换)</li><li><strong>协议转换</strong>: 在不同协议的网络之间转换</li><li><strong>访问控制</strong>: 控制哪些数据可以通过</li></ol><h2 id="Docker-网络架构中的网关"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#Docker-网络架构中的网关" class="headerlink" title="Docker 网络架构中的网关"></a>Docker 网络架构中的网关</h2><h3 id="Docker-桥接网络-Bridge-Network"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#Docker-桥接网络-Bridge-Network" class="headerlink" title="Docker 桥接网络 (Bridge Network)"></a>Docker 桥接网络 (Bridge Network)</h3><p>当你使用 Docker 时,Docker 会创建一个<strong>虚拟网桥 (Virtual Bridge)</strong>,默认名为 <code>docker0</code>。这个虚拟网桥的工作原理类似于物理交换机,它连接了:</p><ul><li>宿主机的网络</li><li>各个容器的虚拟网络接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        宿主机 (Host OS)</span><br><span class="line">        ┌─────────────────────────────────┐</span><br><span class="line">        │                                 │</span><br><span class="line">        │   物理网卡 (eth0)                │</span><br><span class="line">        │  IP: 192.168.0.10               │</span><br><span class="line">        │         ↕                       │</span><br><span class="line">        │  ┌─────────────────┐            │</span><br><span class="line">        │  │   docker0       │            │</span><br><span class="line">        │  │   (虚拟网桥)     │            │</span><br><span class="line">        │  │  172.17.0.1 ←── 这是网关!     │</span><br><span class="line">        │  └────────┬────────┘            │</span><br><span class="line">        │           │                     │</span><br><span class="line">        │     ┌─────┴──────┐              │</span><br><span class="line">        │     │            │              │</span><br><span class="line">        │  ┌──┴──┐     ┌──┴──┐            │</span><br><span class="line">        │  │veth1│     │veth2│            │</span><br><span class="line">        │  └──┬──┘     └──┬──┘            │</span><br><span class="line">        └─────┼──────────┼────────────────┘</span><br><span class="line">              │          │</span><br><span class="line">        ┌─────┴──────────┴─────┐</span><br><span class="line">        │                      │</span><br><span class="line">┌───────┴────────┐     ┌───────┴──────────┐</span><br><span class="line">│  容器 A         │     │  容器 B          │</span><br><span class="line">│  eth0           │    │  eth0            │</span><br><span class="line">│  172.17.0.2     │    │  172.17.0.3      │</span><br><span class="line">│                 │    │                  │</span><br><span class="line">│  网关: 172.17.0.1│    │ 网关: 172.17.0.1 │</span><br><span class="line">└─────────────────┘    └──────────────────┘</span><br></pre></td></tr></table></figure><h3 id="网关-IP-的含义"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#网关-IP-的含义" class="headerlink" title="网关 IP 的含义"></a>网关 IP 的含义</h3><p><strong>Docker 网关 IP (172.17.0.1)</strong> 实际上是:</p><ol><li><strong>虚拟网桥 docker0 在容器网络中的 IP 地址</strong></li><li><strong>容器访问外部网络的出口</strong></li><li><strong>容器访问宿主机的入口</strong></li></ol><h3 id="为什么网关可以访问到宿主机"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#为什么网关可以访问到宿主机" class="headerlink" title="为什么网关可以访问到宿主机?"></a>为什么网关可以访问到宿主机?</h3><p>这是最关键的理解点。让我们一步步分解:</p><h4 id="1-网桥在宿主机上"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#1-网桥在宿主机上" class="headerlink" title="1. 网桥在宿主机上"></a>1. 网桥在宿主机上</h4><p><code>docker0</code> 虚拟网桥实际上是宿主机上的一个网络设备,你可以在宿主机上看到它:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在宿主机上执行</span></span><br><span class="line">ip addr show docker0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类似:</span></span><br><span class="line"><span class="comment"># 4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP</span></span><br><span class="line"><span class="comment">#     link/ether 02:42:5e:8f:32:a1 brd ff:ff:ff:ff:ff:ff</span></span><br><span class="line"><span class="comment">#     inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span></span><br><span class="line"><span class="comment">#        valid_lft forever preferred_lft forever</span></span><br></pre></td></tr></table></figure><h4 id="2-网关既在容器网络中-也在宿主机网络中"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#2-网关既在容器网络中-也在宿主机网络中" class="headerlink" title="2. 网关既在容器网络中,也在宿主机网络中"></a>2. 网关既在容器网络中,也在宿主机网络中</h4><p><code>docker0</code> 网桥是一个特殊的存在,它同时属于两个「世界」:</p><ul><li><strong>在容器的视角</strong>: 172.17.0.1 是网关,是通往外部的出口</li><li><strong>在宿主机的视角</strong>: 172.17.0.1 是本机的一个网络接口</li></ul><p>这就像是一扇门:</p><ul><li>从容器内看,门通往外面(宿主机)</li><li>从宿主机看,门就在自己家里</li></ul><h4 id="3-数据包的流转过程"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#3-数据包的流转过程" class="headerlink" title="3. 数据包的流转过程"></a>3. 数据包的流转过程</h4><p>当容器访问 172.17.0.1 时:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">步骤 1: 容器发送数据包</span><br><span class="line">[容器 172.17.0.2] ---&gt; 目标: 172.17.0.1</span><br><span class="line">                      &quot;我要访问网关&quot;</span><br><span class="line"></span><br><span class="line">步骤 2: 数据包通过 veth pair (虚拟网线)</span><br><span class="line">[容器的 eth0] ---&gt; [veth1] ---&gt; [docker0 网桥]</span><br><span class="line"></span><br><span class="line">步骤 3: docker0 收到数据包</span><br><span class="line">docker0 发现: &quot;这个包是发给我的 (172.17.0.1)&quot;</span><br><span class="line"></span><br><span class="line">步骤 4: 包被宿主机的网络栈处理</span><br><span class="line">由于 docker0 是宿主机上的设备,数据包实际上被宿主机的内核处理</span><br><span class="line"></span><br><span class="line">步骤 5: 如果访问的是宿主机端口 (如 6379)</span><br><span class="line">数据包被转发到宿主机上监听 6379 端口的服务</span><br></pre></td></tr></table></figure><h2 id="详细示例-容器访问宿主机上的-Redis"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#详细示例-容器访问宿主机上的-Redis" class="headerlink" title="详细示例:容器访问宿主机上的 Redis"></a>详细示例:容器访问宿主机上的 Redis</h2><p>让我们通过一个完整的例子来理解:</p><h3 id="场景设置"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#场景设置" class="headerlink" title="场景设置"></a>场景设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 宿主机上启动 Redis (监听所有接口)</span></span><br><span class="line">docker run -d -p 6379:6379 redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看 Docker 网络信息</span></span><br><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p>输出类似:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;IPAM&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.1&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数据包流转详解"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#数据包流转详解" class="headerlink" title="数据包流转详解"></a>数据包流转详解</h3><p>假设 OpenResty 容器 (172.17.0.5) 要访问宿主机的 Redis:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">第 1 步: OpenResty 容器内的代码</span><br><span class="line">────────────────────────────────</span><br><span class="line">red:connect(&quot;172.17.0.1&quot;, 6379)</span><br><span class="line">┌─────────────────────────┐</span><br><span class="line">│ OpenResty 容器           │</span><br><span class="line">│ IP: 172.17.0.5          │</span><br><span class="line">│                         │</span><br><span class="line">│ 发送: SYN 包             │</span><br><span class="line">│ 源: 172.17.0.5:随机端口   │</span><br><span class="line">│ 目标: 172.17.0.1:6379    │</span><br><span class="line">└─────────────────────────┘</span><br><span class="line">         │</span><br><span class="line">         │ 数据包通过容器的网络命名空间</span><br><span class="line">         ↓</span><br><span class="line"></span><br><span class="line">第 2 步: 通过虚拟网卡对 (veth pair)</span><br><span class="line">────────────────────────────────</span><br><span class="line">         │</span><br><span class="line">    [容器内 eth0]</span><br><span class="line">         │</span><br><span class="line">         │ (veth pair 就像一根虚拟网线)</span><br><span class="line">         │</span><br><span class="line">    [宿主机上的 veth-xxx]</span><br><span class="line">         │</span><br><span class="line">         ↓</span><br><span class="line"></span><br><span class="line">第 3 步: 到达 docker0 网桥</span><br><span class="line">────────────────────────────────</span><br><span class="line">┌──────────────────────────┐</span><br><span class="line">│  docker0 虚拟网桥          │</span><br><span class="line">│  IP: 172.17.0.1          │</span><br><span class="line">│                          │</span><br><span class="line">│  收到数据包:               │</span><br><span class="line">│  目标地址是我自己!          │</span><br><span class="line">│  目标端口是 6379           │</span><br><span class="line">└──────────────────────────┘</span><br><span class="line">         │</span><br><span class="line">         │ docker0 是宿主机上的设备</span><br><span class="line">         │ 所以数据包实际上已经&quot;到达&quot;宿主机</span><br><span class="line">         ↓</span><br><span class="line"></span><br><span class="line">第 4 步: 端口转发规则生效</span><br><span class="line">────────────────────────────────</span><br><span class="line">宿主机网络栈处理这个包:</span><br><span class="line">- 目标 IP: 172.17.0.1 (这是本机 IP)</span><br><span class="line">- 目标端口: 6379</span><br><span class="line"></span><br><span class="line">宿主机检查: &quot;有程序在监听 6379 吗?&quot;</span><br><span class="line">- 发现 Redis 容器通过 -p 6379:6379 映射了端口</span><br><span class="line">- iptables 规则将请求转发到 Redis 容器</span><br><span class="line"></span><br><span class="line">第 5 步: 到达 Redis 容器</span><br><span class="line">────────────────────────────────</span><br><span class="line">         │</span><br><span class="line">         ↓</span><br><span class="line">┌─────────────────────────┐</span><br><span class="line">│ Redis 容器               │</span><br><span class="line">│ IP: 172.17.0.2          │</span><br><span class="line">│                         │</span><br><span class="line">│ Redis 服务收到连接请求     │</span><br><span class="line">└─────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="关键的-iptables-规则"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#关键的-iptables-规则" class="headerlink" title="关键的 iptables 规则"></a>关键的 iptables 规则</h3><p>Docker 在宿主机上创建了一系列 iptables 规则来实现端口映射:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在宿主机上查看</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -L -n | grep 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会看到类似规则:</span></span><br><span class="line"><span class="comment"># DNAT  tcp  --  0.0.0.0/0  0.0.0.0/0  tcp dpt:6379 to:172.17.0.2:6379</span></span><br></pre></td></tr></table></figure><p>这条规则的意思是:</p><ul><li>任何到达宿主机 6379 端口的 TCP 连接</li><li>都会被 DNAT (目标地址转换) 到 172.17.0.2:6379 (Redis 容器)</li></ul><h2 id="不同场景下的网关"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#不同场景下的网关" class="headerlink" title="不同场景下的网关"></a>不同场景下的网关</h2><h3 id="1-默认-bridge-网络"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#1-默认-bridge-网络" class="headerlink" title="1. 默认 bridge 网络"></a>1. 默认 bridge 网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><ul><li>网关: 通常是 172.17.0.1</li><li>子网: 172.17.0.0&#x2F;16</li></ul><h3 id="2-自定义-bridge-网络"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#2-自定义-bridge-网络" class="headerlink" title="2. 自定义 bridge 网络"></a>2. 自定义 bridge 网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create --subnet=172.20.0.0/16 my-network</span><br><span class="line">docker network inspect my-network</span><br></pre></td></tr></table></figure><ul><li>网关: 通常是 172.20.0.1 (子网的第一个 IP)</li><li>子网: 172.20.0.0&#x2F;16</li></ul><h3 id="3-docker-compose-创建的网络"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#3-docker-compose-创建的网络" class="headerlink" title="3. docker-compose 创建的网络"></a>3. docker-compose 创建的网络</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp</span></span><br></pre></td></tr></table></figure><p>Docker Compose 会自动创建一个网络,名称类似 <code>projectname_default</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect projectname_default</span><br></pre></td></tr></table></figure><p>输出可能是:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;projectname_default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;IPAM&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这时容器的网关就是 <strong>172.18.0.1</strong></p><h2 id="如何查找容器的网关-IP"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#如何查找容器的网关-IP" class="headerlink" title="如何查找容器的网关 IP"></a>如何查找容器的网关 IP</h2><h3 id="方法-1-在容器内查看路由表"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#方法-1-在容器内查看路由表" class="headerlink" title="方法 1: 在容器内查看路由表"></a>方法 1: 在容器内查看路由表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it container_name sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看默认网关</span></span><br><span class="line">ip route | grep default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># default via 172.18.0.1 dev eth0</span></span><br><span class="line"><span class="comment">#             ^^^^^^^^^^^</span></span><br><span class="line"><span class="comment">#             这就是网关 IP</span></span><br></pre></td></tr></table></figure><h3 id="方法-2-查看容器网络信息"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#方法-2-查看容器网络信息" class="headerlink" title="方法 2: 查看容器网络信息"></a>方法 2: 查看容器网络信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在宿主机上</span></span><br><span class="line">docker inspect container_name | grep Gateway</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span></span><br></pre></td></tr></table></figure><h3 id="方法-3-在容器内读取环境变量"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#方法-3-在容器内读取环境变量" class="headerlink" title="方法 3: 在容器内读取环境变量"></a>方法 3: 在容器内读取环境变量</h3><p>有些情况下,网关 IP 也可以通过解析 DNS 获取:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内</span></span><br><span class="line">getent hosts host.docker.internal</span><br></pre></td></tr></table></figure><h2 id="为什么通过网关能访问宿主机端口"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#为什么通过网关能访问宿主机端口" class="headerlink" title="为什么通过网关能访问宿主机端口"></a>为什么通过网关能访问宿主机端口</h2><p>总结一下关键点:</p><h3 id="1-网关-IP-是宿主机的一部分"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#1-网关-IP-是宿主机的一部分" class="headerlink" title="1. 网关 IP 是宿主机的一部分"></a>1. 网关 IP 是宿主机的一部分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.17.0.1 不是一个&quot;远程&quot;地址</span><br><span class="line">它是宿主机上 docker0 设备的 IP 地址</span><br><span class="line">就像宿主机的 127.0.0.1 或其他网卡 IP 一样</span><br></pre></td></tr></table></figure><h3 id="2-端口映射创建了转发规则"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#2-端口映射创建了转发规则" class="headerlink" title="2. 端口映射创建了转发规则"></a>2. 端口映射创建了转发规则</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 redis</span><br></pre></td></tr></table></figure><p>这个命令做了什么?</p><ol><li>在宿主机的所有网络接口上监听 6379 端口</li><li>包括 docker0 (172.17.0.1) 接口</li><li>创建 iptables 规则: 所有到 6379 的连接 → 转发到 Redis 容器</li></ol><h3 id="3-容器访问网关-访问宿主机"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#3-容器访问网关-访问宿主机" class="headerlink" title="3. 容器访问网关 &#x3D; 访问宿主机"></a>3. 容器访问网关 &#x3D; 访问宿主机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">容器访问 172.17.0.1:6379</span><br><span class="line">    ↓</span><br><span class="line">实际上是访问宿主机的 docker0 接口的 6379 端口</span><br><span class="line">    ↓</span><br><span class="line">宿主机的 iptables 规则生效</span><br><span class="line">    ↓</span><br><span class="line">连接被转发到 Redis 容器的 6379 端口</span><br></pre></td></tr></table></figure><h2 id="常见误区"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><h3 id="误区-1-「网关就是宿主机」"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#误区-1-「网关就是宿主机」" class="headerlink" title="误区 1: 「网关就是宿主机」"></a>误区 1: 「网关就是宿主机」</h3><p><strong>错误理解</strong>: 网关 IP 就是宿主机 IP</p><p><strong>正确理解</strong>: </p><ul><li>网关 IP 是 docker0 虚拟网桥在容器网络中的 IP</li><li>宿主机还有其他 IP (如物理网卡 IP: 192.168.0.10)</li><li>但 docker0 确实是宿主机上的一个设备</li></ul><h3 id="误区-2-「容器可以直接访问宿主机的-127-0-0-1」"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#误区-2-「容器可以直接访问宿主机的-127-0-0-1」" class="headerlink" title="误区 2: 「容器可以直接访问宿主机的 127.0.0.1」"></a>误区 2: 「容器可以直接访问宿主机的 127.0.0.1」</h3><p><strong>错误</strong>: </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">red:connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>)  <span class="comment">-- 不会工作</span></span><br></pre></td></tr></table></figure><p><strong>正确</strong>: </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red:connect(<span class="string">&quot;172.18.0.1&quot;</span>, <span class="number">6379</span>)  <span class="comment">-- 通过网关</span></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line">red:connect(<span class="string">&quot;host.docker.internal&quot;</span>, <span class="number">6379</span>)  <span class="comment">-- Docker Desktop</span></span><br></pre></td></tr></table></figure><h3 id="误区-3-「只有映射了端口才能访问」"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#误区-3-「只有映射了端口才能访问」" class="headerlink" title="误区 3: 「只有映射了端口才能访问」"></a>误区 3: 「只有映射了端口才能访问」</h3><p><strong>部分正确</strong>: </p><ul><li>通过网关访问宿主机端口,需要端口映射 (<code>-p</code>)</li><li>但容器之间直接通信不需要端口映射</li><li>容器可以直接访问其他容器的内部端口</li></ul><h2 id="实际应用示例"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><h3 id="场景-OpenResty-需要连接宿主机上的多个服务"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#场景-OpenResty-需要连接宿主机上的多个服务" class="headerlink" title="场景: OpenResty 需要连接宿主机上的多个服务"></a>场景: OpenResty 需要连接宿主机上的多个服务</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- config.lua</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 动态获取网关 IP</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">get_gateway_ip</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> f = <span class="built_in">io</span>.<span class="built_in">popen</span>(<span class="string">&quot;ip route | grep default | awk &#x27;&#123;print $3&#125;&#x27;&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> gateway = f:<span class="built_in">read</span>(<span class="string">&quot;*line&quot;</span>)</span><br><span class="line">    f:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span> gateway <span class="keyword">or</span> <span class="string">&quot;172.17.0.1&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">_M.gateway = get_gateway_ip()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 服务配置</span></span><br><span class="line">_M.redis_host = _M.gateway</span><br><span class="line">_M.redis_port = <span class="number">6379</span></span><br><span class="line"></span><br><span class="line">_M.mysql_host = _M.gateway</span><br><span class="line">_M.mysql_port = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">_M.elasticsearch_host = _M.gateway</span><br><span class="line">_M.elasticsearch_port = <span class="number">9200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><h3 id="场景-在不同的-Docker-Compose-项目间通信"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#场景-在不同的-Docker-Compose-项目间通信" class="headerlink" title="场景: 在不同的 Docker Compose 项目间通信"></a>场景: 在不同的 Docker Compose 项目间通信</h3><p>最佳方案是使用共享网络,而不是通过网关:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建共享网络</span></span><br><span class="line">docker network create shared-net</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 项目</span></span><br><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    networks:</span><br><span class="line">      - shared-net</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  shared-net:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenResty 项目</span></span><br><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  openresty:</span><br><span class="line">    image: openresty/openresty</span><br><span class="line">    networks:</span><br><span class="line">      - shared-net</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  shared-net:</span><br><span class="line">    external: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样 OpenResty 可以直接使用服务名:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">red:connect(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>)  <span class="comment">-- 直接通过服务名</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="/2025/10/17/Understanding-the-Docker-Host-Gateway/#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Docker 宿主机网关</strong>本质上是:</p><ol><li><strong>虚拟网桥 (docker0) 在容器网络中的 IP 地址</strong></li><li><strong>容器访问宿主机的桥梁</strong></li><li><strong>宿主机网络栈的一部分</strong></li></ol><p>通过网关访问宿主机端口的完整路径:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器 → 容器网关 (docker0) → 宿主机网络栈 → iptables 规则 → 目标容器/服务</span><br></pre></td></tr></table></figure><p>理解了网关的本质,就能明白:</p><ul><li>为什么容器内 127.0.0.1 不能访问宿主机服务</li><li>为什么要使用网关 IP 才能访问</li><li>为什么共享网络是更好的解决方案</li></ul><p>我在遇到前述问题之后，好好查找整理了这个文档，希望能帮助你我彻底理解 Docker 网络架构中的网关概念。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在深入理解 Docker 的宿主机网关之前,我们需要先理解网络中「网关」的基本概念。&lt;/p&gt;
&lt;p&gt;在传统网络中,&lt;strong&gt;网关 (Gateway)&lt;/strong&gt; 是连接两个不同网络的设备或节点。它就像是两个网络之间的「门」，负责在不同网络之间转发数据包。举个生活</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://jwfing.github.io/tags/Docker/"/>
    
    <category term="Network Isolation" scheme="http://jwfing.github.io/tags/Network-Isolation/"/>
    
    <category term="Bridge" scheme="http://jwfing.github.io/tags/Bridge/"/>
    
  </entry>
  
  <entry>
    <title>Why You Can’t Access Local Redis via 127.0.0.1 in a Docker Environment</title>
    <link href="http://jwfing.github.io/2025/10/14/Why-You-Can%E2%80%99t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/"/>
    <id>http://jwfing.github.io/2025/10/14/Why-You-Can%E2%80%99t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/</id>
    <published>2025-10-15T06:09:34.000Z</published>
    <updated>2025-10-18T05:31:14.488Z</updated>
    
    <content type="html"><![CDATA[<p>现在使用 OpenResty 作为反向代理，结合 Redis Cluster 进行服务发现，来动态管理 API 请求，是一种很常见的方案。我们工作中出于测试需要，希望快速搭建一套最小集群，期间出现过一个小问题，我想正好借此讨论一下 Docker 的网络架构。</p><h2 id="场景描述"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>计划的部署方案如下：</p><ul><li><strong>Redis 服务</strong>:通过独立的 docker-compose 配置启动,作为服务发现的存储后端</li><li><strong>OpenResty 服务</strong>:通过另一个 docker-compose 配置启动,作为反向代理,需要从 Redis 中读取上游服务信息。</li></ul><p>两个服务都部署在一台 EC2，项目目录结构大致如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── redis/</span><br><span class="line">│   └── docker-compose.yml</span><br><span class="line">└── openresty/</span><br><span class="line">    └── docker-compose.yml</span><br></pre></td></tr></table></figure><p>Redis 的 docker-compose.yml 示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br></pre></td></tr></table></figure><p>OpenResty 的 docker-compose.yml 示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openresty:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openresty/openresty:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx.conf:/usr/local/openresty/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure><h2 id="问题现象-127-0-0-1-无法访问-Redis"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#问题现象-127-0-0-1-无法访问-Redis" class="headerlink" title="问题现象:127.0.0.1 无法访问 Redis"></a>问题现象:127.0.0.1 无法访问 Redis</h2><p>在 OpenResty 的 Lua 代码中,我们尝试连接 Redis:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">&quot;resty.redis&quot;</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试连接本地 Redis</span></span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;failed to connect to redis: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>运行后,日志中出现连接失败的错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to connect to redis: connection refused</span><br></pre></td></tr></table></figure><p>这让人感到困惑:明明 Redis 已经通过 <code>-p 6379:6379</code> 映射到了宿主机的 6379 端口,为什么在容器内访问 <code>127.0.0.1:6379</code> 却连接不上呢?</p><h2 id="Docker-网络架构解析"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#Docker-网络架构解析" class="headerlink" title="Docker 网络架构解析"></a>Docker 网络架构解析</h2><h3 id="Docker-的网络隔离原理"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#Docker-的网络隔离原理" class="headerlink" title="Docker 的网络隔离原理"></a>Docker 的网络隔离原理</h3><p>要理解这个问题,我们需要了解 Docker 的网络架构。Docker 使用 <strong>Linux namespace</strong> 技术实现网络隔离,每个容器都有自己独立的网络命名空间,包括:</p><ul><li>独立的网络接口</li><li>独立的 IP 地址</li><li>独立的路由表</li><li>独立的端口空间</li></ul><p>当一个容器启动时,Docker 会为其创建一个虚拟网络环境。在这个环境中:</p><ul><li><code>127.0.0.1</code> (localhost) 指向的是<strong>容器自身</strong>,而不是宿主机</li><li>容器有自己的 IP 地址,通常在 Docker 创建的虚拟网桥(默认是 <code>docker0</code>)的子网中</li><li>端口映射(<code>-p 6379:6379</code>)只是在宿主机上建立了一个转发规则</li></ul><h3 id="网络架构示意图"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#网络架构示意图" class="headerlink" title="网络架构示意图"></a>网络架构示意图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│            宿主机 (Host)                     │</span><br><span class="line">│                                             │</span><br><span class="line">│  127.0.0.1:6379 ← Redis 容器端口映射          │</span><br><span class="line">│         ↓                                   │</span><br><span class="line">│  ┌──────────────────┐  ┌─────────────────┐  │</span><br><span class="line">│  │  Redis Cont.     │  │ OpenResty Cont. │  │</span><br><span class="line">│  │                  │  │                 │  │</span><br><span class="line">│  │ 127.0.0.1 → Self │  │ 127.0.0.1 → Self│  │</span><br><span class="line">│  │ CIP: 172.17.0.2  │  │ CIP:172.18.0.2  │  │</span><br><span class="line">│  └──────────────────┘  └─────────────────┘  │</span><br><span class="line">│           ↑                      ↑          │</span><br><span class="line">│           └──────────┬───────────┘          │</span><br><span class="line">│                Docker 网络层                 │</span><br><span class="line">└─────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="为什么-127-0-0-1-不工作"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#为什么-127-0-0-1-不工作" class="headerlink" title="为什么 127.0.0.1 不工作?"></a>为什么 127.0.0.1 不工作?</h3><p>当 OpenResty 容器内的代码尝试连接 <code>127.0.0.1:6379</code> 时:</p><ol><li>这个请求在 OpenResty 容器的网络命名空间内处理</li><li><code>127.0.0.1</code> 指向 OpenResty 容器自己,而不是宿主机</li><li>OpenResty 容器内并没有运行 Redis 服务</li><li>因此连接失败</li></ol><p>虽然宿主机的 6379 端口映射到了 Redis 容器,但这个映射对于 OpenResty 容器来说是”看不见”的,因为它们在不同的网络命名空间中。</p><h2 id="正确的连接方式"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#正确的连接方式" class="headerlink" title="正确的连接方式"></a>正确的连接方式</h2><h3 id="方案一-使用宿主机网关-IP"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#方案一-使用宿主机网关-IP" class="headerlink" title="方案一:使用宿主机网关 IP"></a>方案一:使用宿主机网关 IP</h3><p>每个 Docker 网络都有一个网关 IP,通常是该网络的第一个 IP。对于默认的 bridge 网络,这个 IP 通常是 <code>172.17.0.1</code>。</p><p>在容器内,可以通过以下方式获取网关 IP:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内执行</span></span><br><span class="line">ip route | grep default | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>或者查看 <code>/etc/hosts</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/hosts</span><br><span class="line"><span class="comment"># 通常会看到类似:</span></span><br><span class="line"><span class="comment"># 172.18.0.1    host.docker.internal</span></span><br></pre></td></tr></table></figure><p>修改 OpenResty 的连接代码:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">&quot;resty.redis&quot;</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 Docker 网关 IP 访问宿主机的 Redis 端口</span></span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;172.18.0.1&quot;</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;failed to connect to redis: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>原理</strong>:网关 IP 是容器访问宿主机的桥梁。通过网关 IP,容器可以访问宿主机上暴露的端口,从而通过端口映射访问到 Redis 容器。</p><h3 id="方案二-使用-host-docker-internal-推荐用于开发环境"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#方案二-使用-host-docker-internal-推荐用于开发环境" class="headerlink" title="方案二:使用 host.docker.internal (推荐用于开发环境)"></a>方案二:使用 host.docker.internal (推荐用于开发环境)</h3><p>Docker Desktop 提供了一个特殊的 DNS 名称 <code>host.docker.internal</code>,它会自动解析为宿主机的 IP:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;host.docker.internal&quot;</span>, <span class="number">6379</span>)</span><br></pre></td></tr></table></figure><p>这种方式更加便携,但需要注意:</p><ul><li>Docker Desktop for Mac&#x2F;Windows 默认支持</li><li>Linux 上需要在启动容器时添加 <code>--add-host=host.docker.internal:host-gateway</code></li></ul><h3 id="方案三-使用共享-Docker-网络-最佳实践"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#方案三-使用共享-Docker-网络-最佳实践" class="headerlink" title="方案三:使用共享 Docker 网络(最佳实践)"></a>方案三:使用共享 Docker 网络(最佳实践)</h3><p>最优雅的解决方案是让两个 docker-compose 项目使用同一个 Docker 网络:</p><p>首先创建一个外部网络:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create shared-network</span><br></pre></td></tr></table></figure><p>修改 Redis 的 docker-compose.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shared-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">shared-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>修改 OpenResty 的 docker-compose.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openresty:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openresty/openresty:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shared-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">shared-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后在 OpenResty 中直接使用服务名连接:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接使用服务名,Docker DNS 会自动解析</span></span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>)</span><br></pre></td></tr></table></figure><h2 id="Docker-Compose-的服务名连接机制"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#Docker-Compose-的服务名连接机制" class="headerlink" title="Docker Compose 的服务名连接机制"></a>Docker Compose 的服务名连接机制</h2><h3 id="为什么服务名可以直接使用"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#为什么服务名可以直接使用" class="headerlink" title="为什么服务名可以直接使用?"></a>为什么服务名可以直接使用?</h3><p>当你在同一个 docker-compose.yml 文件中定义多个服务时:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">openresty:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openresty/openresty:latest</span></span><br></pre></td></tr></table></figure><p>在 OpenResty 容器中,你可以直接使用 <code>redis</code> 作为主机名连接 Redis。这是因为:</p><h3 id="1-Docker-内置-DNS-服务器"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#1-Docker-内置-DNS-服务器" class="headerlink" title="1. Docker 内置 DNS 服务器"></a>1. Docker 内置 DNS 服务器</h3><p>Docker 为每个自定义网络(非默认 bridge 网络)提供了一个内置的 DNS 服务器。当容器启动时:</p><ul><li>容器的 <code>/etc/resolv.conf</code> 会被配置为使用 Docker 的 DNS 服务器(通常是 <code>127.0.0.11</code>)</li><li>Docker DNS 会维护一个服务名到容器 IP 的映射表</li></ul><p>查看容器内的 DNS 配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内执行</span></span><br><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br><span class="line"><span class="comment"># 输出类似:</span></span><br><span class="line"><span class="comment"># nameserver 127.0.0.11</span></span><br><span class="line"><span class="comment"># options ndots:0</span></span><br></pre></td></tr></table></figure><h3 id="2-服务发现机制"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#2-服务发现机制" class="headerlink" title="2. 服务发现机制"></a>2. 服务发现机制</h3><p>Docker Compose 会为 compose 文件中定义的每个服务:</p><ul><li>创建一个 DNS 条目,名称就是服务名</li><li>将服务名解析为该服务对应容器的 IP 地址</li><li>如果服务有多个副本(scale),会采用轮询(round-robin)方式返回不同的 IP</li></ul><p>示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 OpenResty 容器内</span></span><br><span class="line">nslookup redis</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># Server:    127.0.0.11</span></span><br><span class="line"><span class="comment"># Address:   127.0.0.11:53</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Name:      redis</span></span><br><span class="line"><span class="comment"># Address:   172.18.0.2  ← Redis 容器的实际 IP</span></span><br></pre></td></tr></table></figure><h3 id="3-网络别名-Network-Aliases"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#3-网络别名-Network-Aliases" class="headerlink" title="3. 网络别名 (Network Aliases)"></a>3. 网络别名 (Network Aliases)</h3><p>Docker 还支持为服务设置网络别名:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">app-network:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">redis-master</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cache-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">app-network:</span></span><br></pre></td></tr></table></figure><p>这样,除了 <code>redis</code> 之外,<code>redis-master</code> 和 <code>cache-server</code> 也都可以解析到同一个容器。</p><h3 id="4-跨-Compose-项目的服务发现"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#4-跨-Compose-项目的服务发现" class="headerlink" title="4. 跨 Compose 项目的服务发现"></a>4. 跨 Compose 项目的服务发现</h3><p>默认情况下,不同 docker-compose 项目的服务无法通过服务名互相访问,因为它们在不同的网络中。这就是为什么我们需要:</p><ul><li>使用共享的外部网络(方案三)</li><li>或者通过宿主机的端口映射(方案一、二)</li></ul><p>使用共享网络后,Docker DNS 会在该网络范围内解析所有加入该网络的服务名。</p><h2 id="最佳实践建议"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h2><h3 id="开发环境"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>对于本地开发,推荐使用共享网络方案:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建共享网络</span></span><br><span class="line">docker network create dev-network</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有开发服务都加入这个网络</span></span><br><span class="line"><span class="comment"># 可以直接使用服务名互相访问</span></span><br></pre></td></tr></table></figure><h3 id="生产环境"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><p>生产环境中,建议:</p><ol><li><strong>使用 Docker Swarm 或 Kubernetes</strong>:它们提供了更强大的服务发现机制</li><li><strong>使用服务网格(Service Mesh)</strong>:如 Istio、Linkerd,提供更高级的流量管理</li><li><strong>使用独立的服务发现组件</strong>:如 Consul、Etcd,不依赖于容器编排平台</li></ol><h3 id="配置管理"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>将 Redis 连接地址配置化:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- config.lua</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从环境变量读取 Redis 地址</span></span><br><span class="line">_M.redis_host = <span class="built_in">os</span>.<span class="built_in">getenv</span>(<span class="string">&quot;REDIS_HOST&quot;</span>) <span class="keyword">or</span> <span class="string">&quot;host.docker.internal&quot;</span></span><br><span class="line">_M.redis_port = <span class="built_in">tonumber</span>(<span class="built_in">os</span>.<span class="built_in">getenv</span>(<span class="string">&quot;REDIS_PORT&quot;</span>)) <span class="keyword">or</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><p>在 docker-compose.yml 中设置环境变量:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openresty:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openresty/openresty:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_PORT=6379</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#总结" class="headerlink" title="总结"></a>总结</h2><p>Docker 的网络隔离是通过 Linux namespace 实现的,每个容器都有独立的网络栈。关键要点:</p><ol><li><strong>容器内的 <code>127.0.0.1</code> 指向容器自身</strong>,而不是宿主机</li><li><strong>端口映射是宿主机层面的</strong>,容器之间无法直接通过 localhost 访问</li><li><strong>容器间通信的正确方式</strong>:<ul><li>使用容器 IP(不推荐,IP 可能变化)</li><li>使用宿主机网关 IP + 端口映射(适合跨 compose 项目)</li><li>使用共享 Docker 网络 + 服务名(最佳实践)</li></ul></li><li><strong>Docker Compose 的服务名解析</strong>依赖于 Docker 内置的 DNS 服务器,自动将服务名映射到容器 IP</li></ol><p>理解 Docker 的网络模型,不仅能解决容器间通信问题,也能帮助我们更好地设计微服务架构，希望这篇文章能帮你更好理解 Docker 的网络隔离。</p><h2 id="参考资料"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.docker.com/network/">Docker Network Documentation</a></li><li><a href="https://docs.docker.com/compose/networking/">Docker Compose Networking</a></li><li><a href="https://github.com/openresty/lua-resty-redis">OpenResty Lua Redis</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在使用 OpenResty 作为反向代理，结合 Redis Cluster 进行服务发现，来动态管理 API 请求，是一种很常见的方案。我们工作中出于测试需要，希望快速搭建一套最小集群，期间出现过一个小问题，我想正好借此讨论一下 Docker 的网络架构。&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://jwfing.github.io/tags/Docker/"/>
    
    <category term="Network Isolation" scheme="http://jwfing.github.io/tags/Network-Isolation/"/>
    
    <category term="Bridge" scheme="http://jwfing.github.io/tags/Bridge/"/>
    
  </entry>
  
  <entry>
    <title>Build an unified observability solution with clickhouse and grafana</title>
    <link href="http://jwfing.github.io/2025/01/24/build-unified-observability-solution-with-clickhouse-grafana/"/>
    <id>http://jwfing.github.io/2025/01/24/build-unified-observability-solution-with-clickhouse-grafana/</id>
    <published>2025-01-25T04:41:38.000Z</published>
    <updated>2025-10-15T05:58:38.925Z</updated>
    
    <content type="html"><![CDATA[<p>soon coming.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;soon coming.&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="observability" scheme="http://jwfing.github.io/tags/observability/"/>
    
    <category term="clickhouse" scheme="http://jwfing.github.io/tags/clickhouse/"/>
    
    <category term="grafana" scheme="http://jwfing.github.io/tags/grafana/"/>
    
    <category term="opentelemetry" scheme="http://jwfing.github.io/tags/opentelemetry/"/>
    
  </entry>
  
  <entry>
    <title>What is observability? beyond logging, metrics, tracing</title>
    <link href="http://jwfing.github.io/2025/01/23/what-is-observability/"/>
    <id>http://jwfing.github.io/2025/01/23/what-is-observability/</id>
    <published>2025-01-24T03:06:20.000Z</published>
    <updated>2025-10-15T05:58:38.925Z</updated>
    
    <content type="html"><![CDATA[<p>可观测性（Observability）是指系统能够提供对其运行状态、性能以及使用情况有全面了解的能力。这一概念在软件开发和运维中非常重要，因为它帮助开发者和运维人员及时发现问题、优化性能并提升用户体验。具体来说，可观测性包含哪些技术呢？</p><ol><li>首先是日志管理系统（logging），这是用来收集和存储应用程序或系统产生的日志信息。比如说 Web 服务器可能会记录每个请求的详细信息，这样可以帮助开发人员调试问题。常见的开源方案有 ELK(ElasticSearch, Logstash&#x2F;Filebeat, Kibana) 和 Grafana(Alloy + Loki)，</li><li>其次是性能监控工具（metrics），比如 Prometheus 或者 Grafana。这类工具能够实时监控系统的各种指标，如 CPU 使用率、内存占用等等。这些数据可以帮助 IT 团队及时发现系统性能下降的情况，从而进行优化。</li><li>分布式跟踪工具（tracing），像 Dapper 或 Jaeger&#x2F;Grafana Tempo，追踪用户请求在整个系统中的流程，帮助识别性能瓶颈和错误来源。</li></ol><p>logging、metrics、tracing 被称为可观测性的三个支柱，但是可观测性不光只有这「三巨头」，还应该包括：</p><ol><li>故障预警与根因分析，是指通过综合分析日志、指标和 tracing 数据，使用机器学习算法预测潜在故障或异常情况，或者面对线上故障进行根因分析。</li><li>网络流量监控，涉及到如何管理和分析网络流量，以确保系统不会被攻击或过载。常用的工具有防火墙、入侵检测系统（IDS）、网络流量分析工具（如 NetFlow&#x2F;sFlow、Calico、Cacti、Flowmeter&#x2F;Flowtop）等。</li><li>安全事件监控，收集并分析安全相关的日志和事件，以及时发现和应对威胁。现在有一些商业化的 SIEM（Security Information and Event Management）系统，如 Splunk、QRadar 等。</li><li>用户行为可观测性，涉及到如何跟踪用户在应用中的活动，分析他们的使用模式。比如，记录用户登录时间、操作频率等信息，帮助优化用户体验。</li></ol><p>可观测性的实现涉及多个关键技术和工具，旨在确保系统的可监控性和可分析性，其核心要素是：</p><ul><li>数据收集：通过日志记录、指标监控、网络流量分析等方式收集系统运行的各种数据。</li><li>数据存储与处理：将收集到的数据存储在合适的数据仓库中，并使用工具进行数据分析和可视化，以便快速获取信息。</li><li>问题检测与根因分析：通过数据分析，及时发现系统异常或性能下降的情况，并利用追踪功能确定问题根源。</li></ul><p>由此可见可观测性不仅仅是监控系统状态，更是一种对整个系统运行情况有深入理解的能力，尤其是在处理复杂、分布式的大型系统时，这变得尤为重要。这是由于：</p><ol><li>复杂性与规模。大型系统通常由多个子服务和组件构成，可能部署在不同的服务器上甚至分布式环境中。传统的监控方法可能难以应对这种复杂性，可观测性通过全面的数据收集和分析能力，帮助管理员有效跟踪各个组件的运行状态。</li><li>性能瓶颈与资源使用。大型系统在高并发或高负载下容易面临性能问题。可观测性提供了对资源（如CPU、内存、网络带宽）的实时监控，帮助识别资源耗尽的情况，并及时优化资源分配。</li><li>故障定位与修复。在大型系统中，错误或崩溃可能出现在任何一个组件。可观测性通过详细的日志和性能数据，便于快速定位问题根源，加快故障修复速度，减少系统停机时间。</li><li>用户体验与业务需求。大型系统往往面向多个用户或企业内部的不同部门。可观测性能够监控用户行为和请求路径，为业务优化提供数据支持，如识别热门功能或性能瓶颈，提升用户满意度。</li><li>自动化运维与自我修复。可观测性赋予系统自我检测和调整的能力。在异常情况下，系统可以根据历史数据和当前状态自动采取措施，如资源调配、服务重启或故障报告，从而减少人工干预。</li><li>扩展性与灵活性。随着业务需求的变化，大型系统需要频繁进行规模调整或功能升级。可观测性提供了对新添加组件和修改后的系统状态的全面监控，确保扩展过程中的稳定性。</li><li>安全事件响应。大型系统通常处理敏感数据，面临更高的安全威胁。通过可观测性的日志分析，可以快速检测异常活动或潜在安全漏洞，加快响应速度，减少潜在损失。</li></ol><p>总之，可观测性是一个涵盖多个技术和工具的概念，其核心在于通过全面、实时的数据收集与分析，帮助系统管理员和开发者更好地了解和管理系统运行状态，它是大型系统实现高效运维、保障性能和用户体验的关键技术，不仅提高了系统的稳定性和可靠性，还支持业务增长和扩展需求。对于那些需要处理海量数据、高并发请求、复杂分布式架构的大型系统来说，可观测性无疑是不可或缺的核心能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可观测性（Observability）是指系统能够提供对其运行状态、性能以及使用情况有全面了解的能力。这一概念在软件开发和运维中非常重要，因为它帮助开发者和运维人员及时发现问题、优化性能并提升用户体验。具体来说，可观测性包含哪些技术呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先是日志</summary>
      
    
    
    
    
    <category term="observability" scheme="http://jwfing.github.io/tags/observability/"/>
    
    <category term="logging" scheme="http://jwfing.github.io/tags/logging/"/>
    
    <category term="metrics" scheme="http://jwfing.github.io/tags/metrics/"/>
    
    <category term="tracing" scheme="http://jwfing.github.io/tags/tracing/"/>
    
    <category term="apps and microservices" scheme="http://jwfing.github.io/tags/apps-and-microservices/"/>
    
  </entry>
  
  <entry>
    <title>Create a todo-hud by yourself</title>
    <link href="http://jwfing.github.io/2016/01/23/create-a-todo-hud-by-yourself/"/>
    <id>http://jwfing.github.io/2016/01/23/create-a-todo-hud-by-yourself/</id>
    <published>2016-01-23T23:06:43.000Z</published>
    <updated>2025-10-15T05:58:38.925Z</updated>
    
    <content type="html"><![CDATA[<p>我已经用过好多款 TodoList 软件，但事情一多总还是丢三落四，原本计划好要做的事情总是安静地躺在某个角落，等我想起来要去扫一眼的时候，都已快「物是人非」。。。</p><p>要是能在桌面上实时显示 TodoList，那该多好！但是 Mac 上做到这一点还真不是一件容易的事，那就退而求其次吧。我想了想，因为公司是使用 Google 办公套件的，自己每天用的最多的软件就是浏览器，要是能在浏览器新开 Tab 页的时候，都能实时显示 TodoList 的话，那就能满足我的需求了。</p><h2 id="最简单的-TodoList"><a href="/2016/01/23/create-a-todo-hud-by-yourself/#最简单的-TodoList" class="headerlink" title="最简单的 TodoList"></a>最简单的 TodoList</h2><p>说做就做，我要的只是一个简单的 web 页面，在上面：</p><ul><li>可以简单展示、创建、关闭待办事项。</li><li>为了通用一点，支持用户账号系统（只要最基本的注册、登录、重置密码就够了）。</li><li>保证内容的私密性。</li></ul><p>所以它不能是一个静态页面，怎么着也要有一个数据库。为了这一点功能，去购买机器、申请域名，甚至还去搞域名备案，实在是不值得，我想 <a href="https://leancloud.app/">LeanCloud</a> 的云引擎应该是最好的选择。</p><p>LeanCloud 云引擎提供了多个应用模版，最简单的一个 <a href="https://github.com/leancloud/node-js-getting-started">node-js-getting-started</a> 就已经包括了一个 web app 的基本框架，并且还附带了一个创建 Todo 的简单例子。在它的基础上，再集成了 LeanCloud 自带的账户系统（连重置密码的功能都默认提供，这里不得不说这真是太方便了）。对于内容私密性，我使用了 LeanCloud 数据存储中的「ACL 机制」，让一条待办事项只有它的所有者可以访问，其他人连读取的权限都没有，这样就保证了用户之间的数据隔离。最后，UI 怎么办呢？对于我这样的前端小白来讲，<a href="http://fezvrasta.github.io/bootstrap-material-design/">bootstrap-material-design</a> 已经是我能想到的最理想的组合了。</p><p>这个项目的所有代码都放在 <a href="https://github.com/jwfing/syncus">github&#x2F;syncus</a> 上了，大家可以自行获取，然后在 LeanCloud 中去部署自己的 web 应用。不过对于想直接试一试的朋友来讲，大家也可以使用这个地址 <a href="https://syncus.avosapps.us/todos">https://syncus.avosapps.us/todos</a> 来访问这一在线的 Todo List。</p><h2 id="让-TodoList-抬头显示"><a href="/2016/01/23/create-a-todo-hud-by-yourself/#让-TodoList-抬头显示" class="headerlink" title="让 TodoList 抬头显示"></a>让 TodoList 抬头显示</h2><p>TodoList 做完了，现在我们要想办法让它能够做到「抬头显示」，否则对我来说也没啥帮助，不过是又造了一个轮子而已。</p><p>以下内容参考了 <a href="http://www.guidingtech.com/8004/have-new-tab-page-open-specific-website-firefox-chrome/">How to Have the New Tab Open a Specific Website Automatically in Chrome and Firefox</a>:</p><h3 id="Chrome-设置"><a href="/2016/01/23/create-a-todo-hud-by-yourself/#Chrome-设置" class="headerlink" title="Chrome 设置"></a>Chrome 设置</h3><p>Chrome 上设置稍微有点复杂，需要借助其他插件，其步骤如下：</p><ol><li>从 Chrome Web Store 下载安装 <a href="https://chromewebstore.google.com/detail/replace-newtab/hdacjmeajjdhbgmmeoebpklfmloifahh">Replace New Tab</a>。</li><li>打开 Chrome 插件管理器（你也可以在地址栏直接输入 chrome:&#x2F;&#x2F;extensions&#x2F;）</li><li>点击 Replace New Tab.</li><li>在地址栏中输入 <strong><a href="https://syncus.avosapps.us/todos">https://syncus.avosapps.us/todos</a></strong>。</li></ol><p>OK，一切都好了，从现在开始，你每次打开一个新的 Tab 页，都会首先看到你自己的待办事项。</p><h3 id="Firefox-设置"><a href="/2016/01/23/create-a-todo-hud-by-yourself/#Firefox-设置" class="headerlink" title="Firefox 设置"></a>Firefox 设置</h3><ol><li>在 Firefox 上我们也需要安装插件 <a href="https://addons.mozilla.org/en-US/firefox/addon/newtaburl/">NewTabURL</a>。</li><li>重启浏览器，可以通过 Ctrl+Shift+A 来打开插件管理页面，找到 NewTabURL 并点击 Options 按钮。</li><li>选择 URL 并输入 <strong><a href="https://syncus.avosapps.us/todos">https://syncus.avosapps.us/todos</a></strong>。</li></ol><h3 id="Safari-设置"><a href="/2016/01/23/create-a-todo-hud-by-yourself/#Safari-设置" class="headerlink" title="Safari 设置"></a>Safari 设置</h3><ol><li>进入 Safari 的设置页面。</li><li>在 <code>Homepage</code> 框中输入 <strong><a href="https://syncus.avosapps.us/todos">https://syncus.avosapps.us/todos</a></strong>，然后把 <code>New tabs open with</code> 中选定 <code>Homepage</code>。</li></ol><h2 id="使用中可能的问题"><a href="/2016/01/23/create-a-todo-hud-by-yourself/#使用中可能的问题" class="headerlink" title="使用中可能的问题"></a>使用中可能的问题</h2><ul><li>Chrome 中 CSS 文件加载不了，页面显示异常</li></ul><p>这可能是因为 LeanCloud 文件托管的域名导致的，可以参考这篇文章解决<a href="http://www.techfor.us/2015/06/your-connection-is-not-private-er_cert_common_name_invalid/">Fix Your Connection is not private error in Chrome</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我已经用过好多款 TodoList 软件，但事情一多总还是丢三落四，原本计划好要做的事情总是安静地躺在某个角落，等我想起来要去扫一眼的时候，都已快「物是人非」。。。&lt;/p&gt;
&lt;p&gt;要是能在桌面上实时显示 TodoList，那该多好！但是 Mac 上做到这一点还真不是一件容易</summary>
      
    
    
    
    
    <category term="leancloud" scheme="http://jwfing.github.io/tags/leancloud/"/>
    
  </entry>
  
</feed>
