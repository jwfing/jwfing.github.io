<!DOCTYPE html>
          <head>
        <meta charset="utf-8">
            
            <title>
                Why You Can’t Access Local Redis via 127.0.0.1 in a Docker Environment | Jonven‘s Blog
            </title>
            <meta content="width=device-width, initial-scale=1" name="viewport">
            <meta name="theme-color" content="#4184f3">
            
            <!-- Favicon -->
            <link rel="icon" type="image/x-icon" href="/favicon.ico">
            <link rel="icon" type="image/png" href="/favicon.png">
            
            

            
<link rel="stylesheet" href="/css/highlight.light.css">

            
<link rel="stylesheet" href="/css/prism-customize.css">

            
<link rel="stylesheet" href="/css/nav-icon.css">

            
<link rel="stylesheet" href="/css/waves.min.css">

            
<link rel="stylesheet" href="/css/jquery.tocify.css">

            
<link rel="stylesheet" href="/css/main.css">

            
<link rel="stylesheet" href="/css/nav-indicator.css">

            
  

  
            </meta>
        </meta>
    <meta name="generator" content="Hexo 7.2.0"></head>

    <body>
        <header>
            <!-- cover image or sth. -->
        </header>
        <div id="main" class="m-scene">
            
<div class="nav-wrapper">

    <div class="container">
        <nav>
            <div class="logo">
                <a href="/" id="logo" class="nav-logo">
                    <img src="/logo.png" alt="logo" class="site-logo">
                    Jonven‘s Blog
                </a>
            </div>
            <div class="nav-toggle-icon" >
                <div class="material-hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <div class="menu-wrapper">
                <ul class="menus">
                    
                     
                        <li>
                            <a class="nav-link " href="/">
                                Home
                            </a>
                        </li>
                     
                        <li>
                            <a class="nav-link " href="/archives">
                                Archive
                            </a>
                        </li>
                     
                        <li>
                            <a class="nav-link " href="/about">
                                About
                            </a>
                        </li>
                     
                        <li>
                            <a class="nav-link no-smoothstate" href="/atom.xml">
                                RSS
                            </a>
                        </li>
                     
                    
                </ul>
            </div>
        </nav>
    </div>
</div>

<style>
.nav-wrapper {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: #fff;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

nav {
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 64px;
    max-width: 800px;
    margin: 0 auto;
    padding: 0 20px;
}

.nav-logo {
    font-size: 1.25rem;
    font-weight: 600;
    color: #111;
    text-decoration: none;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.site-logo {
    height: 32px;
    width: auto;
    display: block;
}

.menu-wrapper {
    display: flex;
    align-items: center;
}

.menus {
    display: flex;
    list-style: none;
    margin: 0;
    padding: 0;
}

.menus li {
    margin: 0 1rem;
}

.menus li a {
    color: #333 !important;
    font-size: 0.95rem;
    font-weight: 500;
    text-decoration: none;
    padding: 0.5rem 0;
    position: relative;
}

.menus li a:hover {
    color: #0066cc !important;
}

.menus li.active a {
    color: #0066cc !important;
}

.menus li.active a::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: #0066cc;
}

@media (max-width: 768px) {
    .menu-wrapper {
        position: fixed;
        top: 64px;
        left: 0;
        right: 0;
        background: #fff;
        padding: 1rem 0;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        transform: translateY(-100%);
        transition: transform 0.3s ease;
    }

    .menu-wrapper.active {
        transform: translateY(0);
    }

    .menus {
        flex-direction: column;
        align-items: center;
    }

    .menus li {
        margin: 0.5rem 0;
    }

    .menus li a {
        display: block;
        padding: 0.5rem 1rem;
    }
}
</style>
            <div class="container content">
                <div class="scene_element scene_element--fadein">
                    <div class="row">
    <div class="main">
        <article>
          
          <header class="post-header">
          
          </header>
          <h1 class="post-title">Why You Can’t Access Local Redis via 127.0.0.1 in a Docker Environment</h1>

          <section class="post-info">
            <span class="post-date">2025/10/14</span>
            
            
            <span class="post-tags">
              <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Bridge/" rel="tag">Bridge</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Network-Isolation/" rel="tag">Network Isolation</a></li></ul>
            </span>
            
          </section>

          <section class="post-content">
            <p>现在使用 OpenResty 作为反向代理，结合 Redis Cluster 进行服务发现，来动态管理 API 请求，是一种很常见的方案。我们工作中出于测试需要，希望快速搭建一套最小集群，期间出现过一个小问题，我想正好借此讨论一下 Docker 的网络架构。</p>
<h2 id="场景描述"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>计划的部署方案如下：</p>
<ul>
<li><strong>Redis 服务</strong>:通过独立的 docker-compose 配置启动,作为服务发现的存储后端</li>
<li><strong>OpenResty 服务</strong>:通过另一个 docker-compose 配置启动,作为反向代理,需要从 Redis 中读取上游服务信息。</li>
</ul>
<p>两个服务都部署在一台 EC2，项目目录结构大致如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── redis/</span><br><span class="line">│   └── docker-compose.yml</span><br><span class="line">└── openresty/</span><br><span class="line">    └── docker-compose.yml</span><br></pre></td></tr></table></figure>

<p>Redis 的 docker-compose.yml 示例:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br></pre></td></tr></table></figure>

<p>OpenResty 的 docker-compose.yml 示例:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openresty:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openresty/openresty:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx.conf:/usr/local/openresty/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure>

<h2 id="问题现象-127-0-0-1-无法访问-Redis"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#问题现象-127-0-0-1-无法访问-Redis" class="headerlink" title="问题现象:127.0.0.1 无法访问 Redis"></a>问题现象:127.0.0.1 无法访问 Redis</h2><p>在 OpenResty 的 Lua 代码中,我们尝试连接 Redis:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">&quot;resty.redis&quot;</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试连接本地 Redis</span></span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;failed to connect to redis: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>运行后,日志中出现连接失败的错误:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to connect to redis: connection refused</span><br></pre></td></tr></table></figure>

<p>这让人感到困惑:明明 Redis 已经通过 <code>-p 6379:6379</code> 映射到了宿主机的 6379 端口,为什么在容器内访问 <code>127.0.0.1:6379</code> 却连接不上呢?</p>
<h2 id="Docker-网络架构解析"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#Docker-网络架构解析" class="headerlink" title="Docker 网络架构解析"></a>Docker 网络架构解析</h2><h3 id="Docker-的网络隔离原理"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#Docker-的网络隔离原理" class="headerlink" title="Docker 的网络隔离原理"></a>Docker 的网络隔离原理</h3><p>要理解这个问题,我们需要了解 Docker 的网络架构。Docker 使用 <strong>Linux namespace</strong> 技术实现网络隔离,每个容器都有自己独立的网络命名空间,包括:</p>
<ul>
<li>独立的网络接口</li>
<li>独立的 IP 地址</li>
<li>独立的路由表</li>
<li>独立的端口空间</li>
</ul>
<p>当一个容器启动时,Docker 会为其创建一个虚拟网络环境。在这个环境中:</p>
<ul>
<li><code>127.0.0.1</code> (localhost) 指向的是<strong>容器自身</strong>,而不是宿主机</li>
<li>容器有自己的 IP 地址,通常在 Docker 创建的虚拟网桥(默认是 <code>docker0</code>)的子网中</li>
<li>端口映射(<code>-p 6379:6379</code>)只是在宿主机上建立了一个转发规则</li>
</ul>
<h3 id="网络架构示意图"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#网络架构示意图" class="headerlink" title="网络架构示意图"></a>网络架构示意图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│            宿主机 (Host)                     │</span><br><span class="line">│                                              │</span><br><span class="line">│  127.0.0.1:6379 ← Redis 容器端口映射         │</span><br><span class="line">│         ↓                                    │</span><br><span class="line">│  ┌──────────────────┐  ┌─────────────────┐  │</span><br><span class="line">│  │  Redis 容器       │  │ OpenResty 容器   │  │</span><br><span class="line">│  │                   │  │                  │  │</span><br><span class="line">│  │ 127.0.0.1 → 自己  │  │ 127.0.0.1 → 自己 │  │</span><br><span class="line">│  │ 容器IP: 172.17.0.2│  │ 容器IP: 172.18.0.2│ │</span><br><span class="line">│  └──────────────────┘  └─────────────────┘  │</span><br><span class="line">│           ↑                      ↑           │</span><br><span class="line">│           └──────────┬───────────┘           │</span><br><span class="line">│                Docker 网络层                 │</span><br><span class="line">└─────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="为什么-127-0-0-1-不工作"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#为什么-127-0-0-1-不工作" class="headerlink" title="为什么 127.0.0.1 不工作?"></a>为什么 127.0.0.1 不工作?</h3><p>当 OpenResty 容器内的代码尝试连接 <code>127.0.0.1:6379</code> 时:</p>
<ol>
<li>这个请求在 OpenResty 容器的网络命名空间内处理</li>
<li><code>127.0.0.1</code> 指向 OpenResty 容器自己,而不是宿主机</li>
<li>OpenResty 容器内并没有运行 Redis 服务</li>
<li>因此连接失败</li>
</ol>
<p>虽然宿主机的 6379 端口映射到了 Redis 容器,但这个映射对于 OpenResty 容器来说是”看不见”的,因为它们在不同的网络命名空间中。</p>
<h2 id="正确的连接方式"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#正确的连接方式" class="headerlink" title="正确的连接方式"></a>正确的连接方式</h2><h3 id="方案一-使用宿主机网关-IP"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#方案一-使用宿主机网关-IP" class="headerlink" title="方案一:使用宿主机网关 IP"></a>方案一:使用宿主机网关 IP</h3><p>每个 Docker 网络都有一个网关 IP,通常是该网络的第一个 IP。对于默认的 bridge 网络,这个 IP 通常是 <code>172.17.0.1</code>。</p>
<p>在容器内,可以通过以下方式获取网关 IP:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内执行</span></span><br><span class="line">ip route | grep default | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>或者查看 <code>/etc/hosts</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/hosts</span><br><span class="line"><span class="comment"># 通常会看到类似:</span></span><br><span class="line"><span class="comment"># 172.18.0.1    host.docker.internal</span></span><br></pre></td></tr></table></figure>

<p>修改 OpenResty 的连接代码:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">&quot;resty.redis&quot;</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 Docker 网关 IP 访问宿主机的 Redis 端口</span></span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;172.18.0.1&quot;</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;failed to connect to redis: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>原理</strong>:网关 IP 是容器访问宿主机的桥梁。通过网关 IP,容器可以访问宿主机上暴露的端口,从而通过端口映射访问到 Redis 容器。</p>
<h3 id="方案二-使用-host-docker-internal-推荐用于开发环境"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#方案二-使用-host-docker-internal-推荐用于开发环境" class="headerlink" title="方案二:使用 host.docker.internal (推荐用于开发环境)"></a>方案二:使用 host.docker.internal (推荐用于开发环境)</h3><p>Docker Desktop 提供了一个特殊的 DNS 名称 <code>host.docker.internal</code>,它会自动解析为宿主机的 IP:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;host.docker.internal&quot;</span>, <span class="number">6379</span>)</span><br></pre></td></tr></table></figure>

<p>这种方式更加便携,但需要注意:</p>
<ul>
<li>Docker Desktop for Mac&#x2F;Windows 默认支持</li>
<li>Linux 上需要在启动容器时添加 <code>--add-host=host.docker.internal:host-gateway</code></li>
</ul>
<h3 id="方案三-使用共享-Docker-网络-最佳实践"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#方案三-使用共享-Docker-网络-最佳实践" class="headerlink" title="方案三:使用共享 Docker 网络(最佳实践)"></a>方案三:使用共享 Docker 网络(最佳实践)</h3><p>最优雅的解决方案是让两个 docker-compose 项目使用同一个 Docker 网络:</p>
<p>首先创建一个外部网络:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create shared-network</span><br></pre></td></tr></table></figure>

<p>修改 Redis 的 docker-compose.yml:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shared-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">shared-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>修改 OpenResty 的 docker-compose.yml:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openresty:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openresty/openresty:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shared-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">shared-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后在 OpenResty 中直接使用服务名连接:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接使用服务名,Docker DNS 会自动解析</span></span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Docker-Compose-的服务名连接机制"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#Docker-Compose-的服务名连接机制" class="headerlink" title="Docker Compose 的服务名连接机制"></a>Docker Compose 的服务名连接机制</h2><h3 id="为什么服务名可以直接使用"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#为什么服务名可以直接使用" class="headerlink" title="为什么服务名可以直接使用?"></a>为什么服务名可以直接使用?</h3><p>当你在同一个 docker-compose.yml 文件中定义多个服务时:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">openresty:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openresty/openresty:latest</span></span><br></pre></td></tr></table></figure>

<p>在 OpenResty 容器中,你可以直接使用 <code>redis</code> 作为主机名连接 Redis。这是因为:</p>
<h3 id="1-Docker-内置-DNS-服务器"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#1-Docker-内置-DNS-服务器" class="headerlink" title="1. Docker 内置 DNS 服务器"></a>1. Docker 内置 DNS 服务器</h3><p>Docker 为每个自定义网络(非默认 bridge 网络)提供了一个内置的 DNS 服务器。当容器启动时:</p>
<ul>
<li>容器的 <code>/etc/resolv.conf</code> 会被配置为使用 Docker 的 DNS 服务器(通常是 <code>127.0.0.11</code>)</li>
<li>Docker DNS 会维护一个服务名到容器 IP 的映射表</li>
</ul>
<p>查看容器内的 DNS 配置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内执行</span></span><br><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br><span class="line"><span class="comment"># 输出类似:</span></span><br><span class="line"><span class="comment"># nameserver 127.0.0.11</span></span><br><span class="line"><span class="comment"># options ndots:0</span></span><br></pre></td></tr></table></figure>

<h3 id="2-服务发现机制"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#2-服务发现机制" class="headerlink" title="2. 服务发现机制"></a>2. 服务发现机制</h3><p>Docker Compose 会为 compose 文件中定义的每个服务:</p>
<ul>
<li>创建一个 DNS 条目,名称就是服务名</li>
<li>将服务名解析为该服务对应容器的 IP 地址</li>
<li>如果服务有多个副本(scale),会采用轮询(round-robin)方式返回不同的 IP</li>
</ul>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 OpenResty 容器内</span></span><br><span class="line">nslookup redis</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># Server:    127.0.0.11</span></span><br><span class="line"><span class="comment"># Address:   127.0.0.11:53</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Name:      redis</span></span><br><span class="line"><span class="comment"># Address:   172.18.0.2  ← Redis 容器的实际 IP</span></span><br></pre></td></tr></table></figure>

<h3 id="3-网络别名-Network-Aliases"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#3-网络别名-Network-Aliases" class="headerlink" title="3. 网络别名 (Network Aliases)"></a>3. 网络别名 (Network Aliases)</h3><p>Docker 还支持为服务设置网络别名:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">app-network:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">redis-master</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cache-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">app-network:</span></span><br></pre></td></tr></table></figure>

<p>这样,除了 <code>redis</code> 之外,<code>redis-master</code> 和 <code>cache-server</code> 也都可以解析到同一个容器。</p>
<h3 id="4-跨-Compose-项目的服务发现"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#4-跨-Compose-项目的服务发现" class="headerlink" title="4. 跨 Compose 项目的服务发现"></a>4. 跨 Compose 项目的服务发现</h3><p>默认情况下,不同 docker-compose 项目的服务无法通过服务名互相访问,因为它们在不同的网络中。这就是为什么我们需要:</p>
<ul>
<li>使用共享的外部网络(方案三)</li>
<li>或者通过宿主机的端口映射(方案一、二)</li>
</ul>
<p>使用共享网络后,Docker DNS 会在该网络范围内解析所有加入该网络的服务名。</p>
<h2 id="最佳实践建议"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h2><h3 id="开发环境"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>对于本地开发,推荐使用共享网络方案:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建共享网络</span></span><br><span class="line">docker network create dev-network</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有开发服务都加入这个网络</span></span><br><span class="line"><span class="comment"># 可以直接使用服务名互相访问</span></span><br></pre></td></tr></table></figure>

<h3 id="生产环境"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><p>生产环境中,建议:</p>
<ol>
<li><strong>使用 Docker Swarm 或 Kubernetes</strong>:它们提供了更强大的服务发现机制</li>
<li><strong>使用服务网格(Service Mesh)</strong>:如 Istio、Linkerd,提供更高级的流量管理</li>
<li><strong>使用独立的服务发现组件</strong>:如 Consul、Etcd,不依赖于容器编排平台</li>
</ol>
<h3 id="配置管理"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>将 Redis 连接地址配置化:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- config.lua</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从环境变量读取 Redis 地址</span></span><br><span class="line">_M.redis_host = <span class="built_in">os</span>.<span class="built_in">getenv</span>(<span class="string">&quot;REDIS_HOST&quot;</span>) <span class="keyword">or</span> <span class="string">&quot;host.docker.internal&quot;</span></span><br><span class="line">_M.redis_port = <span class="built_in">tonumber</span>(<span class="built_in">os</span>.<span class="built_in">getenv</span>(<span class="string">&quot;REDIS_PORT&quot;</span>)) <span class="keyword">or</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>

<p>在 docker-compose.yml 中设置环境变量:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openresty:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openresty/openresty:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_PORT=6379</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#总结" class="headerlink" title="总结"></a>总结</h2><p>Docker 的网络隔离是通过 Linux namespace 实现的,每个容器都有独立的网络栈。关键要点:</p>
<ol>
<li><strong>容器内的 <code>127.0.0.1</code> 指向容器自身</strong>,而不是宿主机</li>
<li><strong>端口映射是宿主机层面的</strong>,容器之间无法直接通过 localhost 访问</li>
<li><strong>容器间通信的正确方式</strong>:<ul>
<li>使用容器 IP(不推荐,IP 可能变化)</li>
<li>使用宿主机网关 IP + 端口映射(适合跨 compose 项目)</li>
<li>使用共享 Docker 网络 + 服务名(最佳实践)</li>
</ul>
</li>
<li><strong>Docker Compose 的服务名解析</strong>依赖于 Docker 内置的 DNS 服务器,自动将服务名映射到容器 IP</li>
</ol>
<p>理解 Docker 的网络模型,不仅能解决容器间通信问题,也能帮助我们更好地设计微服务架构，希望这篇文章能帮你更好理解 Docker 的网络隔离。</p>
<h2 id="参考资料"><a href="/2025/10/14/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/network/">Docker Network Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/networking/">Docker Compose Networking</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/openresty/lua-resty-redis">OpenResty Lua Redis</a></li>
</ul>

          </section>
        </article>
        

       
        <div class="pager">
          
          
            <a class="post-next pager-item" href="/2025/01/24/build-unified-observability-solution-with-clickhouse-grafana/">
              <strong class="article-nav-caption">Older</strong>
              <p class="post-nav-title">Build an unified observability solution with clickhouse and grafana</p>
            </a>
          
        </div>
        

         <!-- comments -->
        <div class="comment-section">
  
    

    <!-- 多说评论框 start -->
      <div class="ds-thread" data-thread-key="_posts/Why-You-Can’t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment.md" data-title="Why You Can’t Access Local Redis via 127.0.0.1 in a Docker Environment" data-url="http://jwfing.github.io/2025/10/14/Why-You-Can%E2%80%99t-Access-Local-Redis-via-127-0-0-1-in-a-Docker-Environment/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
      <script type="text/javascript">
      var duoshuoQuery = {short_name:"wayouliu"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->

  


</div>

    </div>
    
</div>

                </div>
            </div>
        </div>
        <footer class="footer">
    <p>由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动，搭载<a target="_blank" rel="noopener" href="https://github.com/wayou/hexo-theme-gstyle">gstyle</a>主题</p>
    <p>
        &copy; 2025 Jonven Feng
    </p>
</footer>

<script src="/lib/jquery.js"></script>


<script src="/lib/waves.js"></script>


<script src="/lib/jquery-ui.js"></script>


<script src="/lib/jquery.tocify.js"></script>


<script src="/js/main.js"></script>


    </body>
</html>
